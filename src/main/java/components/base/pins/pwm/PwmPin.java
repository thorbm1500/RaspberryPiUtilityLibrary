package components.base.pins.pwm;

import com.pi4j.context.Context;
import com.pi4j.io.pwm.Pwm;
import com.pi4j.io.pwm.PwmPreset;
import com.pi4j.io.pwm.PwmType;
import components.base.pins.Pin;
import lombok.SneakyThrows;
import org.jetbrains.annotations.NotNull;

import java.util.Map;

@SuppressWarnings("unused")
public class PwmPin extends Pin {

    protected int frequency = 50;

    private float dutyCycle = 0;

    protected final Pwm pin;
    private final PwmType type;

    public PwmPin(@NotNull final Context pi4j, @NotNull final PinIdentifier pin) throws IllegalStateException,IllegalArgumentException {
        super(pi4j,pin);
        type = identifier.getGpioType().equals(GpioType.HW_PWM) ? PwmType.HARDWARE : PwmType.SOFTWARE;
        final int pinNumber = pin.getPin();
        this.pin = pi4j.create(Pwm.newConfigBuilder(pi4j)
                .id("PWM_PIN#%d".formatted(pinNumber))
                .name("Pin %d".formatted(pinNumber))
                .address(pinNumber)
                .pwmType(type)
                .frequency(frequency)
                .initial(dutyCycle)
                .shutdown(0)
                .build());
    }

    public void setDutyCycle(final float value, final boolean force) throws IllegalArgumentException {
        if (value < 0 || value > 100) throw new IllegalArgumentException("A duty cycle cannot physically be more than 100 or less than 0!");
        dutyCycle = value;
        pin.setDutyCycle(dutyCycle);
        if (force) pin.on(value);
    }

    /**
     * Update the frequency of the PWM. Note: This will not update the PWM live, unless <b>force</b> is set to true.
     * @param hz The new frequency. Default is 50.
     * @return The PWM Pin Instance.
     * @throws IllegalArgumentException If the frequency is less than 0.
     * @throws IllegalArgumentException If the Pin only supports Software PWM, and the frequency is set higher than 5000,
     * otherwise if the frequency is set higher than 100,000.
     * @apiNote <i>This setting is <b>optional</b>.</i>
     */
    public PwmPin frequency(final int hz) throws IllegalStateException {
        return frequency(hz, false);
    }

    /**
     * Update the frequency of the PWM. Note: This will not update the PWM live, unless <b>force</b> is set to true.
     * @param hz The new frequency. Default is 50.
     * @param force True, if the PWM should be updated immediately, otherwise false.
     * @return The PWM Pin Instance.
     * @throws IllegalArgumentException If the frequency is less than 0.
     * @throws IllegalArgumentException If the Pin only supports Software PWM, and the frequency is set higher than 5000,
     * otherwise if the frequency is set higher than 100,000.
     * @apiNote <i>This setting is <b>optional</b>.</i>
     */
    @SneakyThrows
    public PwmPin frequency(final int hz, final boolean force) throws IllegalArgumentException {
        if (hz < 0) throw new IllegalArgumentException("The frequency cannot physically be less than zero!");
        else if (type == PwmType.SOFTWARE && hz > 5000) throw new IllegalArgumentException("A software enabled PWM pin cannot exceed a frequency of 5000!");
        else if (hz > 100000) throw new IllegalArgumentException("A hardware enabled PWM pin cannot exceed a frequency of 100,000!");
        this.frequency = hz;
        pin.frequency(hz);
        if (force) pin.on();
        return this;
    }

    /**
     * Get the actual frequency that's currently being generated by the PWM signal generator.
     * @return The Hz as a Number.
     */
    public Number actualFrequency() {
        return pin.actualFrequency();
    }

    /**
     * Get the current frequceny set.
     * @return The current frequency. This might not reflect the actual live frequency,
     * but rather the latest frequency set by the user.
     */
    public int frequency() {
        return this.frequency;
    }

    public void on(final Number dutyCycle) {
        pin.on(dutyCycle);
    }

    public void on(final Number dutyCycle, final int frequency) {
        pin.on(dutyCycle, frequency);
    }

    public void on() {
        pin.on();
    }

    public boolean isOn() {
        return pin.isOn();
    }

    public void update() {
        on();
    }

    public void off() {
        pin.off();
    }

    public boolean isOff() {
        return pin.isOff();
    }

    public Map<String,PwmPreset> presets() {
        return pin.getPresets();
    }

    public void addPreset(final PwmPreset preset) {
        pin.addPreset(preset);
    }

    public void removePreset(final PwmPreset preset) {
        removePreset(preset.name());
    }

    public void removePreset(@NotNull final String name) {
        pin.deletePreset(name);
    }

    public void applyPreset(final PwmPreset preset) {
        applyPreset(preset.name());
    }

    public void applyPreset(@NotNull final String name) {
        pin.applyPreset(name);
    }

    public PwmPreset getPreset(@NotNull final String name) {
        return pin.getPreset(name);
    }

    public Number address() {
        return pin.getAddress();
    }

    private boolean isValidDutyCycle(final float amount) throws IllegalArgumentException {
        if (amount > 100) throw new IllegalArgumentException("A duty cycle cannot physically be more than 100!");
        else if (amount < 0) throw new IllegalArgumentException("A duty cycle cannot physically be less than 0!");
        else return true;
    }
}